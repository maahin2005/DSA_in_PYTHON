# DSA: Data structure and Algorithm

- Target Make Tea:

- Input: water, tea powder, milk, sugar
- output: Tea
  <!--rod: Kg -->
  <!-- apple: gr/kg -->
  <!-- Time: sec/min -->

<!-- 1 cup of tea -->
<!-- Kirthika di -->

<!-- spoon - variable ; milk ,water => object and arr  -->

### varible => constant time complexity => O(1)

- Boild the Milk - half cup of milk
- mix water little bit - half water of cup
- then Tea powder - 1 spoon - single var
- then sugar - 1 spoon

<!-- Karan -->

- boil the water - 1 spoon of water
- then tea - 2 spoon
- after boils adding milk - 2 cup of milk
- sugar - 1 spoon of sugar

<!-- abijeet  -->

- water boiling
- tea powder
- milk
- then sugar

<!-- Khushi -->

- boil milk
- then water
- sugar
- tea

<!-- Result of this all indivisul process -->

## We want Tea

### Time complexity O(1)/constant

- const myName = "Name"; // TC: O(1) => Constant Time Complexity
- const myValue = "val"
- const obj = {}
- const arr = []
- conditions (if .... else...)

### Map over the array:

- O(N) # where N is the size/length of the array

<!-- TC: O() -->

- you have arr - unsorted --> Data
- We want to sort it --> all the step for sorting this arr is the called as Algorithm
- what you we get --> sorted arr

### const arr = [1,2,3,4,5] - O(n) - o(5) - n= length of the arr

- Primitive data types creation are O(1)/constant -->
- Non Primitve data types creation are O(N)-->

1. O(1)
2. O(log n) - length: 8: log of 8? 3
3. O(N)
4. O(n log n) // mixer of 2nd and 3rd
5. O(N^2)

O(1) < O(log n) < O(n) < O(n log n) < O(N^2) < O(2^n) < O(n!)

- n lon n => o(n) + O(log n)
  any Number > log of that number
  5 > 2
